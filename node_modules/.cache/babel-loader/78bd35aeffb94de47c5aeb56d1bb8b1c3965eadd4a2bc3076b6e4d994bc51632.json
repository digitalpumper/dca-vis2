{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\lozan\\\\Desktop\\\\Git\\\\dca-spotfire\\\\frontend\\\\src\\\\InteractiveDCAChart.js\",\n  _s = $RefreshSig$();\nimport React, { useEffect, useRef, useState, useMemo } from 'react';\nimport * as d3 from 'd3';\n\n// Helper: Darken a HEX color.\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst darkenColor = (hex, factor = 0.8) => {\n  let c = d3.color(hex);\n  if (c) {\n    c.r = Math.floor(c.r * factor);\n    c.g = Math.floor(c.g * factor);\n    c.b = Math.floor(c.b * factor);\n    return c.formatHex();\n  }\n  return hex;\n};\n\n// Helper: Lighten a HEX color.\nconst lightenColor = (hex, factor = 1.2) => {\n  let c = d3.color(hex);\n  if (c) {\n    c.r = Math.min(255, Math.floor(c.r * factor));\n    c.g = Math.min(255, Math.floor(c.g * factor));\n    c.b = Math.min(255, Math.floor(c.b * factor));\n    return c.formatHex();\n  }\n  return hex;\n};\n\n// Given an array of headers, auto-detect measurement columns.\nconst detectColumns = headers => {\n  let phases = {};\n  headers.forEach(header => {\n    const lower = header.toLowerCase();\n    if (lower.includes(\"bopd\")) {\n      phases.oil = header;\n    } else if (lower.includes(\"oil\") && !phases.oil) {\n      phases.oil = header;\n    }\n    if (lower.includes(\"bwpd\")) {\n      phases.water = header;\n    } else if (lower.includes(\"water\") && !phases.water) {\n      phases.water = header;\n    }\n    if (lower.includes(\"mcfd\")) {\n      phases.gas = header;\n    } else if (lower.includes(\"gas\") && !phases.gas) {\n      phases.gas = header;\n    }\n    if ((lower.includes(\"pip\") || lower.includes(\"pressure\") || lower.includes(\"psi\")) && !phases.pressure) {\n      phases.pressure = header;\n    }\n  });\n  return phases;\n};\nconst InteractiveDCAChart = ({\n  data,\n  columns\n}) => {\n  _s();\n  const svgRef = useRef();\n  const width = 900;\n  const height = 500;\n  // We'll use a fixed forecast initial value of 100 for testing.\n  const forecastInitial = 100;\n\n  // For simplicity, we assume the production date column is provided explicitly.\n  const dateCol = columns.date;\n\n  // Prepare parsed data with proper Date objects.\n  const parsedData = useMemo(() => {\n    return data.map(d => ({\n      ...d,\n      date: new Date(d[dateCol])\n    })).filter(d => d.date && !isNaN(d.date.getTime()));\n  }, [data, dateCol]);\n\n  // Sort data by date.\n  parsedData.sort((a, b) => a.date - b.date);\n\n  // Set up scales.\n  useEffect(() => {\n    if (parsedData.length === 0) return;\n    const svg = d3.select(svgRef.current);\n    svg.selectAll(\"*\").remove();\n\n    // X Scale based on production dates.\n    const xScale = d3.scaleTime().domain(d3.extent(parsedData, d => d.date)).range([50, width - 50]);\n\n    // Y Scale based on maximum production from any phase.\n    const phaseKeys = [\"oil\", \"water\", \"gas\", \"pressure\"];\n    const yMax = d3.max(parsedData, d => {\n      return d3.max(phaseKeys, key => d[key] ? +d[key] : 0);\n    });\n    const yScale = d3.scaleLinear().domain([0, yMax * 1.2]).range([height - 50, 50]);\n\n    // Axes.\n    svg.append(\"g\").attr(\"transform\", `translate(0,${height - 50})`).call(d3.axisBottom(xScale));\n    svg.append(\"g\").attr(\"transform\", `translate(50,0)`).call(d3.axisLeft(yScale));\n\n    // Plot historical data points for each phase.\n    phaseKeys.forEach(key => {\n      if (!columns[key]) return;\n      svg.selectAll(`circle.${key}`).data(parsedData).enter().append(\"circle\").attr(\"class\", key).attr(\"cx\", d => xScale(d.date)).attr(\"cy\", d => yScale(d[key])).attr(\"r\", 3).attr(\"fill\", key === \"oil\" ? \"green\" : key === \"water\" ? \"blue\" : key === \"gas\" ? \"red\" : \"black\");\n    });\n\n    // Historical decline curves based on actual data (for now, simply draw a line connecting data points).\n    phaseKeys.forEach(key => {\n      if (!columns[key]) return;\n      const line = d3.line().x(d => xScale(d.date)).y(d => yScale(d[key]));\n      svg.append(\"path\").datum(parsedData).attr(\"fill\", \"none\").attr(\"stroke\", key === \"oil\" ? \"green\" : key === \"water\" ? \"blue\" : key === \"gas\" ? \"red\" : \"black\").attr(\"stroke-width\", 2).attr(\"d\", line);\n    });\n\n    // Forecast curves.\n    // For testing, forecast for each phase starting today with initial value 100,\n    // and using the same decline parameters (default: b=0.9, D=0.01) for all.\n    const forecastDays = 30; // Forecast for 30 days.\n    const today = new Date();\n    const forecastDates = d3.timeDays(today, d3.timeDay.offset(today, forecastDays));\n    phaseKeys.forEach(key => {\n      if (!columns[key]) return;\n      const b = 0.9,\n        D = 0.01; // default parameters.\n      // Generate forecast values.\n      const forecastData = forecastDates.map((d, i) => ({\n        date: d,\n        value: forecastInitial / Math.pow(1 + b * D * i, 1 / b)\n      }));\n      const forecastLine = d3.line().x(d => xScale(d.date)).y(d => yScale(d.value));\n      // Draw forecast as a solid line in a lighter color.\n      svg.append(\"path\").datum(forecastData).attr(\"fill\", \"none\").attr(\"stroke\", lightenColor(key === \"oil\" ? \"green\" : key === \"water\" ? \"blue\" : key === \"gas\" ? \"red\" : \"black\", 1.2)).attr(\"stroke-width\", 3).attr(\"d\", forecastLine);\n    });\n  }, [parsedData, columns]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n      style: {\n        marginTop: \"20px\"\n      },\n      children: \"Interactive DCA Chart\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 161,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"svg\", {\n      ref: svgRef,\n      width: width,\n      height: height\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 162,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 160,\n    columnNumber: 5\n  }, this);\n};\n_s(InteractiveDCAChart, \"8gjBPXaq+KX0Xp91xpblpIaR/Us=\");\n_c = InteractiveDCAChart;\nexport default InteractiveDCAChart;\nvar _c;\n$RefreshReg$(_c, \"InteractiveDCAChart\");","map":{"version":3,"names":["React","useEffect","useRef","useState","useMemo","d3","jsxDEV","_jsxDEV","darkenColor","hex","factor","c","color","r","Math","floor","g","b","formatHex","lightenColor","min","detectColumns","headers","phases","forEach","header","lower","toLowerCase","includes","oil","water","gas","pressure","InteractiveDCAChart","data","columns","_s","svgRef","width","height","forecastInitial","dateCol","date","parsedData","map","d","Date","filter","isNaN","getTime","sort","a","length","svg","select","current","selectAll","remove","xScale","scaleTime","domain","extent","range","phaseKeys","yMax","max","key","yScale","scaleLinear","append","attr","call","axisBottom","axisLeft","enter","line","x","y","datum","forecastDays","today","forecastDates","timeDays","timeDay","offset","D","forecastData","i","value","pow","forecastLine","children","style","marginTop","fileName","_jsxFileName","lineNumber","columnNumber","ref","_c","$RefreshReg$"],"sources":["C:/Users/lozan/Desktop/Git/dca-spotfire/frontend/src/InteractiveDCAChart.js"],"sourcesContent":["import React, { useEffect, useRef, useState, useMemo } from 'react';\r\nimport * as d3 from 'd3';\r\n\r\n// Helper: Darken a HEX color.\r\nconst darkenColor = (hex, factor = 0.8) => {\r\n  let c = d3.color(hex);\r\n  if (c) {\r\n    c.r = Math.floor(c.r * factor);\r\n    c.g = Math.floor(c.g * factor);\r\n    c.b = Math.floor(c.b * factor);\r\n    return c.formatHex();\r\n  }\r\n  return hex;\r\n};\r\n\r\n// Helper: Lighten a HEX color.\r\nconst lightenColor = (hex, factor = 1.2) => {\r\n  let c = d3.color(hex);\r\n  if (c) {\r\n    c.r = Math.min(255, Math.floor(c.r * factor));\r\n    c.g = Math.min(255, Math.floor(c.g * factor));\r\n    c.b = Math.min(255, Math.floor(c.b * factor));\r\n    return c.formatHex();\r\n  }\r\n  return hex;\r\n};\r\n\r\n// Given an array of headers, auto-detect measurement columns.\r\nconst detectColumns = (headers) => {\r\n  let phases = {};\r\n  headers.forEach(header => {\r\n    const lower = header.toLowerCase();\r\n    if (lower.includes(\"bopd\")) {\r\n      phases.oil = header;\r\n    } else if (lower.includes(\"oil\") && !phases.oil) {\r\n      phases.oil = header;\r\n    }\r\n    if (lower.includes(\"bwpd\")) {\r\n      phases.water = header;\r\n    } else if (lower.includes(\"water\") && !phases.water) {\r\n      phases.water = header;\r\n    }\r\n    if (lower.includes(\"mcfd\")) {\r\n      phases.gas = header;\r\n    } else if (lower.includes(\"gas\") && !phases.gas) {\r\n      phases.gas = header;\r\n    }\r\n    if ((lower.includes(\"pip\") || lower.includes(\"pressure\") || lower.includes(\"psi\")) && !phases.pressure) {\r\n      phases.pressure = header;\r\n    }\r\n  });\r\n  return phases;\r\n};\r\n\r\nconst InteractiveDCAChart = ({ data, columns }) => {\r\n  const svgRef = useRef();\r\n  const width = 900;\r\n  const height = 500;\r\n  // We'll use a fixed forecast initial value of 100 for testing.\r\n  const forecastInitial = 100;\r\n  \r\n  // For simplicity, we assume the production date column is provided explicitly.\r\n  const dateCol = columns.date;\r\n  \r\n  // Prepare parsed data with proper Date objects.\r\n  const parsedData = useMemo(() => {\r\n    return data.map(d => ({\r\n      ...d,\r\n      date: new Date(d[dateCol])\r\n    })).filter(d => d.date && !isNaN(d.date.getTime()));\r\n  }, [data, dateCol]);\r\n  \r\n  // Sort data by date.\r\n  parsedData.sort((a, b) => a.date - b.date);\r\n  \r\n  // Set up scales.\r\n  useEffect(() => {\r\n    if (parsedData.length === 0) return;\r\n    const svg = d3.select(svgRef.current);\r\n    svg.selectAll(\"*\").remove();\r\n\r\n    // X Scale based on production dates.\r\n    const xScale = d3.scaleTime()\r\n      .domain(d3.extent(parsedData, d => d.date))\r\n      .range([50, width - 50]);\r\n    \r\n    // Y Scale based on maximum production from any phase.\r\n    const phaseKeys = [\"oil\", \"water\", \"gas\", \"pressure\"];\r\n    const yMax = d3.max(parsedData, d => {\r\n      return d3.max(phaseKeys, key => d[key] ? +d[key] : 0);\r\n    });\r\n    const yScale = d3.scaleLinear()\r\n      .domain([0, yMax * 1.2])\r\n      .range([height - 50, 50]);\r\n\r\n    // Axes.\r\n    svg.append(\"g\")\r\n      .attr(\"transform\", `translate(0,${height - 50})`)\r\n      .call(d3.axisBottom(xScale));\r\n    svg.append(\"g\")\r\n      .attr(\"transform\", `translate(50,0)`)\r\n      .call(d3.axisLeft(yScale));\r\n\r\n    // Plot historical data points for each phase.\r\n    phaseKeys.forEach(key => {\r\n      if (!columns[key]) return;\r\n      svg.selectAll(`circle.${key}`)\r\n        .data(parsedData)\r\n        .enter()\r\n        .append(\"circle\")\r\n        .attr(\"class\", key)\r\n        .attr(\"cx\", d => xScale(d.date))\r\n        .attr(\"cy\", d => yScale(d[key]))\r\n        .attr(\"r\", 3)\r\n        .attr(\"fill\", key === \"oil\" ? \"green\" : key === \"water\" ? \"blue\" : key === \"gas\" ? \"red\" : \"black\");\r\n    });\r\n\r\n    // Historical decline curves based on actual data (for now, simply draw a line connecting data points).\r\n    phaseKeys.forEach(key => {\r\n      if (!columns[key]) return;\r\n      const line = d3.line()\r\n        .x(d => xScale(d.date))\r\n        .y(d => yScale(d[key]));\r\n      svg.append(\"path\")\r\n        .datum(parsedData)\r\n        .attr(\"fill\", \"none\")\r\n        .attr(\"stroke\", key === \"oil\" ? \"green\" : key === \"water\" ? \"blue\" : key === \"gas\" ? \"red\" : \"black\")\r\n        .attr(\"stroke-width\", 2)\r\n        .attr(\"d\", line);\r\n    });\r\n\r\n    // Forecast curves.\r\n    // For testing, forecast for each phase starting today with initial value 100,\r\n    // and using the same decline parameters (default: b=0.9, D=0.01) for all.\r\n    const forecastDays = 30; // Forecast for 30 days.\r\n    const today = new Date();\r\n    const forecastDates = d3.timeDays(today, d3.timeDay.offset(today, forecastDays));\r\n    phaseKeys.forEach(key => {\r\n      if (!columns[key]) return;\r\n      const b = 0.9, D = 0.01; // default parameters.\r\n      // Generate forecast values.\r\n      const forecastData = forecastDates.map((d, i) => ({\r\n        date: d,\r\n        value: forecastInitial / Math.pow(1 + b * D * i, 1 / b)\r\n      }));\r\n      const forecastLine = d3.line()\r\n        .x(d => xScale(d.date))\r\n        .y(d => yScale(d.value));\r\n      // Draw forecast as a solid line in a lighter color.\r\n      svg.append(\"path\")\r\n        .datum(forecastData)\r\n        .attr(\"fill\", \"none\")\r\n        .attr(\"stroke\", lightenColor(key === \"oil\" ? \"green\" : key === \"water\" ? \"blue\" : key === \"gas\" ? \"red\" : \"black\", 1.2))\r\n        .attr(\"stroke-width\", 3)\r\n        .attr(\"d\", forecastLine);\r\n    });\r\n  }, [parsedData, columns]);\r\n\r\n  return (\r\n    <div>\r\n      <h3 style={{ marginTop: \"20px\" }}>Interactive DCA Chart</h3>\r\n      <svg ref={svgRef} width={width} height={height}></svg>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default InteractiveDCAChart;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}