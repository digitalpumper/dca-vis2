{"ast":null,"code":"import _defineProperty from 'babel-runtime/helpers/defineProperty';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n/* eslint-disable react/prop-types */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport shallowEqual from 'shallowequal';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\nvar Range = function (_React$Component) {\n  _inherits(Range, _React$Component);\n  function Range(props) {\n    _classCallCheck(this, Range);\n    var _this = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, props));\n    _this.onEnd = function () {\n      _this.removeDocumentEvents();\n      _this.props.onAfterChange(_this.getValue());\n    };\n    var count = props.count,\n      min = props.min,\n      max = props.max;\n    var initialValue = Array.apply(undefined, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _this.trimAlignValue(v, i);\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n  _createClass(Range, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var _this2 = this;\n      if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return;\n      if (this.props.min === nextProps.min && this.props.max === nextProps.max && shallowEqual(this.props.value, nextProps.value)) {\n        return;\n      }\n      var bounds = this.state.bounds;\n      var value = nextProps.value || bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _this2.trimAlignValue(v, i, nextProps);\n      });\n      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {\n        return v === bounds[i];\n      })) return;\n      this.setState({\n        bounds: nextBounds\n      });\n      if (bounds.some(function (v) {\n        return utils.isValueOutOfRange(v, nextProps);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, nextProps);\n        });\n        this.props.onChange(newValues);\n      }\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n      if (isNotControlled) {\n        this.setState(state);\n      } else if (state.handle !== undefined) {\n        this.setState({\n          handle: state.handle\n        });\n      }\n      var data = _extends({}, this.state, state);\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: 'onStart',\n    value: function onStart(position) {\n      var props = this.props;\n      var state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({\n        bounds: nextBounds\n      });\n    }\n  }, {\n    key: 'onMove',\n    value: function onMove(e, position) {\n      utils.pauseEvent(e);\n      var state = this.state;\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n      this.moveTo(value);\n    }\n  }, {\n    key: 'onKeyboard',\n    value: function onKeyboard(e) {\n      var valueMutator = utils.getKeyboardValueMutator(e);\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n          props = this.props;\n        var bounds = state.bounds,\n          handle = state.handle;\n        var oldValue = bounds[handle];\n        var mutatedValue = valueMutator(oldValue, props);\n        var value = this.trimAlignValue(mutatedValue);\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: 'getClosestBound',\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n      var closestBound = 0;\n      for (var i = 1; i < bounds.length - 1; ++i) {\n        if (value > bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    }\n  }, {\n    key: 'getBoundNeedMoving',\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _state = this.state,\n        bounds = _state.bounds,\n        recent = _state.recent;\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    }\n  }, {\n    key: 'getLowerBound',\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: 'getUpperBound',\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n      return bounds[bounds.length - 1];\n    }\n\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n  }, {\n    key: 'getPoints',\n    value: function getPoints() {\n      var _props = this.props,\n        marks = _props.marks,\n        step = _props.step,\n        min = _props.min,\n        max = _props.max;\n      var cache = this._getPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this._getPointsCache = {\n          marks: marks,\n          step: step,\n          points: points\n        };\n      }\n      return this._getPointsCache.points;\n    }\n  }, {\n    key: 'moveTo',\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n      var state = this.state,\n        props = this.props;\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      nextBounds[state.handle] = value;\n      var nextHandle = state.handle;\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n      }\n    }\n  }, {\n    key: 'pushSurroundingHandles',\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var threshold = this.props.pushable;\n      threshold = Number(threshold);\n      var direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n      if (direction === 0) {\n        return;\n      }\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: 'pushHandle',\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    }\n  }, {\n    key: 'pushHandleOnePoint',\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var threshold = this.props.pushable;\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: 'trimAlignValue',\n    value: function trimAlignValue(v, handle) {\n      var nextProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var mergedProps = _extends({}, this.props, nextProps);\n      var valInRange = utils.ensureValueInRange(v, mergedProps);\n      var valNotConflict = this.ensureValueNotConflict(handle, valInRange, mergedProps);\n      return utils.ensureValuePrecision(valNotConflict, mergedProps);\n    }\n  }, {\n    key: 'ensureValueNotConflict',\n    value: function ensureValueNotConflict(handle, val, _ref) {\n      var allowCross = _ref.allowCross,\n        thershold = _ref.pushable;\n      var state = this.state || {};\n      var bounds = state.bounds;\n      handle = handle === undefined ? state.handle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n      return val;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n      var _state2 = this.state,\n        handle = _state2.handle,\n        bounds = _state2.bounds;\n      var _props2 = this.props,\n        prefixCls = _props2.prefixCls,\n        vertical = _props2.vertical,\n        included = _props2.included,\n        disabled = _props2.disabled,\n        min = _props2.min,\n        max = _props2.max,\n        handleGenerator = _props2.handle,\n        trackStyle = _props2.trackStyle,\n        handleStyle = _props2.handleStyle,\n        tabIndex = _props2.tabIndex;\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n      var handleClassName = prefixCls + '-handle';\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, handleClassName + '-' + (i + 1), true), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          offset: offsets[i],\n          value: v,\n          dragging: handle === i,\n          index: i,\n          tabIndex: tabIndex[i] || 0,\n          min: min,\n          max: max,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          }\n        });\n      });\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, prefixCls + '-track', true), _defineProperty(_classNames2, prefixCls + '-track-' + i, true), _classNames2));\n        return React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n      return {\n        tracks: tracks,\n        handles: handles\n      };\n    }\n  }]);\n  return Range;\n}(React.Component);\nRange.displayName = 'Range';\nRange.propTypes = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: PropTypes.number,\n  pushable: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n  allowCross: PropTypes.bool,\n  disabled: PropTypes.bool,\n  tabIndex: PropTypes.arrayOf(PropTypes.number)\n};\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  tabIndex: []\n};\nexport default createSlider(Range);","map":{"version":3,"names":["_defineProperty","_extends","_toConsumableArray","_classCallCheck","_createClass","_possibleConstructorReturn","_inherits","React","PropTypes","classNames","shallowEqual","Track","createSlider","utils","Range","_React$Component","props","_this","__proto__","Object","getPrototypeOf","call","onEnd","removeDocumentEvents","onAfterChange","getValue","count","min","max","initialValue","Array","apply","undefined","map","defaultValue","value","bounds","v","i","trimAlignValue","recent","length","state","handle","key","componentWillReceiveProps","nextProps","_this2","nextBounds","every","setState","some","isValueOutOfRange","newValues","ensureValueInRange","onChange","isNotControlled","data","changedValue","onStart","position","onBeforeChange","calcValueByPos","startValue","startPosition","closestBound","getClosestBound","prevMovedHandleIndex","getBoundNeedMoving","prevValue","concat","onMove","e","pauseEvent","oldValue","moveTo","onKeyboard","valueMutator","getKeyboardValueMutator","mutatedValue","isFromKeyboardEvent","Math","abs","_state","boundNeedMoving","isAtTheSamePoint","getLowerBound","getUpperBound","getPoints","_props","marks","step","cache","_getPointsCache","pointsObject","point","points","keys","parseFloat","sort","a","b","_this3","nextHandle","pushable","pushSurroundingHandles","allowCross","indexOf","handlesRefs","focus","threshold","Number","direction","diffToNext","pushHandle","amount","originalValue","currentValue","pushHandleOnePoint","pointIndex","nextPointIndex","nextValue","arguments","mergedProps","valInRange","valNotConflict","ensureValueNotConflict","ensureValuePrecision","val","_ref","thershold","render","_this4","_state2","_props2","prefixCls","vertical","included","disabled","handleGenerator","trackStyle","handleStyle","tabIndex","offsets","calcOffset","handleClassName","handles","_classNames","className","offset","dragging","index","style","ref","h","saveHandle","tracks","slice","_","_classNames2","trackClassName","createElement","Component","displayName","propTypes","arrayOf","number","oneOfType","bool","defaultProps"],"sources":["C:/Users/lozan/Desktop/Git/dca-spotfire/frontend/node_modules/rc-slider/es/Range.js"],"sourcesContent":["import _defineProperty from 'babel-runtime/helpers/defineProperty';\nimport _extends from 'babel-runtime/helpers/extends';\nimport _toConsumableArray from 'babel-runtime/helpers/toConsumableArray';\nimport _classCallCheck from 'babel-runtime/helpers/classCallCheck';\nimport _createClass from 'babel-runtime/helpers/createClass';\nimport _possibleConstructorReturn from 'babel-runtime/helpers/possibleConstructorReturn';\nimport _inherits from 'babel-runtime/helpers/inherits';\n/* eslint-disable react/prop-types */\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport classNames from 'classnames';\nimport shallowEqual from 'shallowequal';\nimport Track from './common/Track';\nimport createSlider from './common/createSlider';\nimport * as utils from './utils';\n\nvar Range = function (_React$Component) {\n  _inherits(Range, _React$Component);\n\n  function Range(props) {\n    _classCallCheck(this, Range);\n\n    var _this = _possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).call(this, props));\n\n    _this.onEnd = function () {\n      _this.removeDocumentEvents();\n      _this.props.onAfterChange(_this.getValue());\n    };\n\n    var count = props.count,\n        min = props.min,\n        max = props.max;\n\n    var initialValue = Array.apply(undefined, _toConsumableArray(Array(count + 1))).map(function () {\n      return min;\n    });\n    var defaultValue = 'defaultValue' in props ? props.defaultValue : initialValue;\n    var value = props.value !== undefined ? props.value : defaultValue;\n    var bounds = value.map(function (v, i) {\n      return _this.trimAlignValue(v, i);\n    });\n    var recent = bounds[0] === max ? 0 : bounds.length - 1;\n\n    _this.state = {\n      handle: null,\n      recent: recent,\n      bounds: bounds\n    };\n    return _this;\n  }\n\n  _createClass(Range, [{\n    key: 'componentWillReceiveProps',\n    value: function componentWillReceiveProps(nextProps) {\n      var _this2 = this;\n\n      if (!('value' in nextProps || 'min' in nextProps || 'max' in nextProps)) return;\n      if (this.props.min === nextProps.min && this.props.max === nextProps.max && shallowEqual(this.props.value, nextProps.value)) {\n        return;\n      }\n\n      var bounds = this.state.bounds;\n\n      var value = nextProps.value || bounds;\n      var nextBounds = value.map(function (v, i) {\n        return _this2.trimAlignValue(v, i, nextProps);\n      });\n      if (nextBounds.length === bounds.length && nextBounds.every(function (v, i) {\n        return v === bounds[i];\n      })) return;\n\n      this.setState({ bounds: nextBounds });\n\n      if (bounds.some(function (v) {\n        return utils.isValueOutOfRange(v, nextProps);\n      })) {\n        var newValues = value.map(function (v) {\n          return utils.ensureValueInRange(v, nextProps);\n        });\n        this.props.onChange(newValues);\n      }\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange(state) {\n      var props = this.props;\n      var isNotControlled = !('value' in props);\n      if (isNotControlled) {\n        this.setState(state);\n      } else if (state.handle !== undefined) {\n        this.setState({ handle: state.handle });\n      }\n\n      var data = _extends({}, this.state, state);\n      var changedValue = data.bounds;\n      props.onChange(changedValue);\n    }\n  }, {\n    key: 'onStart',\n    value: function onStart(position) {\n      var props = this.props;\n      var state = this.state;\n      var bounds = this.getValue();\n      props.onBeforeChange(bounds);\n\n      var value = this.calcValueByPos(position);\n      this.startValue = value;\n      this.startPosition = position;\n\n      var closestBound = this.getClosestBound(value);\n      this.prevMovedHandleIndex = this.getBoundNeedMoving(value, closestBound);\n\n      this.setState({\n        handle: this.prevMovedHandleIndex,\n        recent: this.prevMovedHandleIndex\n      });\n\n      var prevValue = bounds[this.prevMovedHandleIndex];\n      if (value === prevValue) return;\n\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      nextBounds[this.prevMovedHandleIndex] = value;\n      this.onChange({ bounds: nextBounds });\n    }\n  }, {\n    key: 'onMove',\n    value: function onMove(e, position) {\n      utils.pauseEvent(e);\n      var state = this.state;\n\n      var value = this.calcValueByPos(position);\n      var oldValue = state.bounds[state.handle];\n      if (value === oldValue) return;\n\n      this.moveTo(value);\n    }\n  }, {\n    key: 'onKeyboard',\n    value: function onKeyboard(e) {\n      var valueMutator = utils.getKeyboardValueMutator(e);\n\n      if (valueMutator) {\n        utils.pauseEvent(e);\n        var state = this.state,\n            props = this.props;\n        var bounds = state.bounds,\n            handle = state.handle;\n\n        var oldValue = bounds[handle];\n        var mutatedValue = valueMutator(oldValue, props);\n        var value = this.trimAlignValue(mutatedValue);\n        if (value === oldValue) return;\n        var isFromKeyboardEvent = true;\n        this.moveTo(value, isFromKeyboardEvent);\n      }\n    }\n  }, {\n    key: 'getValue',\n    value: function getValue() {\n      return this.state.bounds;\n    }\n  }, {\n    key: 'getClosestBound',\n    value: function getClosestBound(value) {\n      var bounds = this.state.bounds;\n\n      var closestBound = 0;\n      for (var i = 1; i < bounds.length - 1; ++i) {\n        if (value > bounds[i]) {\n          closestBound = i;\n        }\n      }\n      if (Math.abs(bounds[closestBound + 1] - value) < Math.abs(bounds[closestBound] - value)) {\n        closestBound += 1;\n      }\n      return closestBound;\n    }\n  }, {\n    key: 'getBoundNeedMoving',\n    value: function getBoundNeedMoving(value, closestBound) {\n      var _state = this.state,\n          bounds = _state.bounds,\n          recent = _state.recent;\n\n      var boundNeedMoving = closestBound;\n      var isAtTheSamePoint = bounds[closestBound + 1] === bounds[closestBound];\n\n      if (isAtTheSamePoint && bounds[recent] === bounds[closestBound]) {\n        boundNeedMoving = recent;\n      }\n\n      if (isAtTheSamePoint && value !== bounds[closestBound + 1]) {\n        boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;\n      }\n      return boundNeedMoving;\n    }\n  }, {\n    key: 'getLowerBound',\n    value: function getLowerBound() {\n      return this.state.bounds[0];\n    }\n  }, {\n    key: 'getUpperBound',\n    value: function getUpperBound() {\n      var bounds = this.state.bounds;\n\n      return bounds[bounds.length - 1];\n    }\n\n    /**\n     * Returns an array of possible slider points, taking into account both\n     * `marks` and `step`. The result is cached.\n     */\n\n  }, {\n    key: 'getPoints',\n    value: function getPoints() {\n      var _props = this.props,\n          marks = _props.marks,\n          step = _props.step,\n          min = _props.min,\n          max = _props.max;\n\n      var cache = this._getPointsCache;\n      if (!cache || cache.marks !== marks || cache.step !== step) {\n        var pointsObject = _extends({}, marks);\n        if (step !== null) {\n          for (var point = min; point <= max; point += step) {\n            pointsObject[point] = point;\n          }\n        }\n        var points = Object.keys(pointsObject).map(parseFloat);\n        points.sort(function (a, b) {\n          return a - b;\n        });\n        this._getPointsCache = { marks: marks, step: step, points: points };\n      }\n      return this._getPointsCache.points;\n    }\n  }, {\n    key: 'moveTo',\n    value: function moveTo(value, isFromKeyboardEvent) {\n      var _this3 = this;\n\n      var state = this.state,\n          props = this.props;\n\n      var nextBounds = [].concat(_toConsumableArray(state.bounds));\n      nextBounds[state.handle] = value;\n      var nextHandle = state.handle;\n      if (props.pushable !== false) {\n        this.pushSurroundingHandles(nextBounds, nextHandle);\n      } else if (props.allowCross) {\n        nextBounds.sort(function (a, b) {\n          return a - b;\n        });\n        nextHandle = nextBounds.indexOf(value);\n      }\n      this.onChange({\n        handle: nextHandle,\n        bounds: nextBounds\n      });\n      if (isFromKeyboardEvent) {\n        // known problem: because setState is async,\n        // so trigger focus will invoke handler's onEnd and another handler's onStart too early,\n        // cause onBeforeChange and onAfterChange receive wrong value.\n        // here use setState callback to hack，but not elegant\n        this.setState({}, function () {\n          _this3.handlesRefs[nextHandle].focus();\n        });\n      }\n    }\n  }, {\n    key: 'pushSurroundingHandles',\n    value: function pushSurroundingHandles(bounds, handle) {\n      var value = bounds[handle];\n      var threshold = this.props.pushable;\n\n      threshold = Number(threshold);\n\n      var direction = 0;\n      if (bounds[handle + 1] - value < threshold) {\n        direction = +1; // push to right\n      }\n      if (value - bounds[handle - 1] < threshold) {\n        direction = -1; // push to left\n      }\n\n      if (direction === 0) {\n        return;\n      }\n\n      var nextHandle = handle + direction;\n      var diffToNext = direction * (bounds[nextHandle] - value);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // revert to original value if pushing is impossible\n        bounds[handle] = bounds[nextHandle] - direction * threshold;\n      }\n    }\n  }, {\n    key: 'pushHandle',\n    value: function pushHandle(bounds, handle, direction, amount) {\n      var originalValue = bounds[handle];\n      var currentValue = bounds[handle];\n      while (direction * (currentValue - originalValue) < amount) {\n        if (!this.pushHandleOnePoint(bounds, handle, direction)) {\n          // can't push handle enough to create the needed `amount` gap, so we\n          // revert its position to the original value\n          bounds[handle] = originalValue;\n          return false;\n        }\n        currentValue = bounds[handle];\n      }\n      // the handle was pushed enough to create the needed `amount` gap\n      return true;\n    }\n  }, {\n    key: 'pushHandleOnePoint',\n    value: function pushHandleOnePoint(bounds, handle, direction) {\n      var points = this.getPoints();\n      var pointIndex = points.indexOf(bounds[handle]);\n      var nextPointIndex = pointIndex + direction;\n      if (nextPointIndex >= points.length || nextPointIndex < 0) {\n        // reached the minimum or maximum available point, can't push anymore\n        return false;\n      }\n      var nextHandle = handle + direction;\n      var nextValue = points[nextPointIndex];\n      var threshold = this.props.pushable;\n\n      var diffToNext = direction * (bounds[nextHandle] - nextValue);\n      if (!this.pushHandle(bounds, nextHandle, direction, threshold - diffToNext)) {\n        // couldn't push next handle, so we won't push this one either\n        return false;\n      }\n      // push the handle\n      bounds[handle] = nextValue;\n      return true;\n    }\n  }, {\n    key: 'trimAlignValue',\n    value: function trimAlignValue(v, handle) {\n      var nextProps = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      var mergedProps = _extends({}, this.props, nextProps);\n      var valInRange = utils.ensureValueInRange(v, mergedProps);\n      var valNotConflict = this.ensureValueNotConflict(handle, valInRange, mergedProps);\n      return utils.ensureValuePrecision(valNotConflict, mergedProps);\n    }\n  }, {\n    key: 'ensureValueNotConflict',\n    value: function ensureValueNotConflict(handle, val, _ref) {\n      var allowCross = _ref.allowCross,\n          thershold = _ref.pushable;\n\n      var state = this.state || {};\n      var bounds = state.bounds;\n\n      handle = handle === undefined ? state.handle : handle;\n      thershold = Number(thershold);\n      /* eslint-disable eqeqeq */\n      if (!allowCross && handle != null && bounds !== undefined) {\n        if (handle > 0 && val <= bounds[handle - 1] + thershold) {\n          return bounds[handle - 1] + thershold;\n        }\n        if (handle < bounds.length - 1 && val >= bounds[handle + 1] - thershold) {\n          return bounds[handle + 1] - thershold;\n        }\n      }\n      /* eslint-enable eqeqeq */\n      return val;\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this4 = this;\n\n      var _state2 = this.state,\n          handle = _state2.handle,\n          bounds = _state2.bounds;\n      var _props2 = this.props,\n          prefixCls = _props2.prefixCls,\n          vertical = _props2.vertical,\n          included = _props2.included,\n          disabled = _props2.disabled,\n          min = _props2.min,\n          max = _props2.max,\n          handleGenerator = _props2.handle,\n          trackStyle = _props2.trackStyle,\n          handleStyle = _props2.handleStyle,\n          tabIndex = _props2.tabIndex;\n\n\n      var offsets = bounds.map(function (v) {\n        return _this4.calcOffset(v);\n      });\n\n      var handleClassName = prefixCls + '-handle';\n      var handles = bounds.map(function (v, i) {\n        var _classNames;\n\n        return handleGenerator({\n          className: classNames((_classNames = {}, _defineProperty(_classNames, handleClassName, true), _defineProperty(_classNames, handleClassName + '-' + (i + 1), true), _classNames)),\n          prefixCls: prefixCls,\n          vertical: vertical,\n          offset: offsets[i],\n          value: v,\n          dragging: handle === i,\n          index: i,\n          tabIndex: tabIndex[i] || 0,\n          min: min,\n          max: max,\n          disabled: disabled,\n          style: handleStyle[i],\n          ref: function ref(h) {\n            return _this4.saveHandle(i, h);\n          }\n        });\n      });\n\n      var tracks = bounds.slice(0, -1).map(function (_, index) {\n        var _classNames2;\n\n        var i = index + 1;\n        var trackClassName = classNames((_classNames2 = {}, _defineProperty(_classNames2, prefixCls + '-track', true), _defineProperty(_classNames2, prefixCls + '-track-' + i, true), _classNames2));\n        return React.createElement(Track, {\n          className: trackClassName,\n          vertical: vertical,\n          included: included,\n          offset: offsets[i - 1],\n          length: offsets[i] - offsets[i - 1],\n          style: trackStyle[index],\n          key: i\n        });\n      });\n\n      return { tracks: tracks, handles: handles };\n    }\n  }]);\n\n  return Range;\n}(React.Component);\n\nRange.displayName = 'Range';\nRange.propTypes = {\n  defaultValue: PropTypes.arrayOf(PropTypes.number),\n  value: PropTypes.arrayOf(PropTypes.number),\n  count: PropTypes.number,\n  pushable: PropTypes.oneOfType([PropTypes.bool, PropTypes.number]),\n  allowCross: PropTypes.bool,\n  disabled: PropTypes.bool,\n  tabIndex: PropTypes.arrayOf(PropTypes.number)\n};\nRange.defaultProps = {\n  count: 1,\n  allowCross: true,\n  pushable: false,\n  tabIndex: []\n};\n\n\nexport default createSlider(Range);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}